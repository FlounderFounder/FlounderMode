<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Supabase Sync Test - Floundermode Dictionary</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="../favicon.ico" />
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    
    <!-- CSS Files -->
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/easy-mode.css">
    <link rel="stylesheet" href="../styles/voting-ui.css">
  </head>
  <body>
    <header class="main-header">
      <div class="header-content">
        <h1 class="page-title">Floundermode Dictionary</h1>
        <nav class="header-nav">
          <a href="../" class="nav-button">‚Üê Back to Dictionary</a>
        <button class="nav-button dark-mode-toggle" onclick="toggleDarkMode()">
          üåô Dark
        </button>
        </nav>
      </div>
    </header>

    <main class="main-content">
      <div class="term-page">
        <h1 class="term-title">Supabase Sync Test</h1>
        
        <div class="definitions-container">
          <h2 class="definitions-title">DEFINITIONS</h2>
          <div class="definitions-list">
            
            <div class="definition-item" id="def-1">
              <div class="definition-content">
                <div class="definition-text">This term was created to test if the GitHub Action successfully syncs new terms with Supabase database. If you can see this definition in your Supabase dashboard, the sync is working!</div>
                <div class="definition-example">"This is a test term to verify Supabase synchronization."</div>
              </div>
              <div class="definition-author">by GitHub Action 2025-09-23</div>
              <div class="definition-votes">
                <button class="vote-btn vote-up" onclick="submitVote('def-1', 'up')" data-def-id="def-1">
                  ‚ñ≤
                </button>
                <div class="vote-count">0</div>
                <button class="vote-btn vote-down" onclick="submitVote('def-1', 'down')" data-def-id="def-1">
                  ‚ñº
                </button>
                <button class="share-btn" onclick="shareDefinition('def-1')" data-def-id="def-1" title="Share this definition">
                  üì§
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <div class="term-related">
          <h2>Related Terms</h2>
          <div class="related-tags">
            <span class="related-tag">Testing</span>
            <span class="related-tag">Supabase</span>
            <span class="related-tag">Automation</span>
            <span class="related-tag">Sync</span>
          </div>
        </div>
        
        <div class="term-actions">
          <button onclick="shareSupabaseSyncTest()" class="share-button">
            üì§ Share This Term
          </button>
        </div>
        
        <script>
          function shareSupabaseSyncTest() {
            const definitions = [
          {
                    "id": "def-1",
                    "definition": "This term was created to test if the GitHub Action successfully syncs new terms with Supabase database. If you can see this definition in your Supabase dashboard, the sync is working!",
                    "usage": "This is a test term to verify Supabase synchronization.",
                    "author": "GitHub Action",
                    "isPrimary": true,
                    "upvotes": 0,
                    "downvotes": 0,
                    "netScore": 0
          }
];
            shareTerm('Supabase Sync Test', definitions);
          }
          
          // Share term function for individual pages
          window.shareTerm = function(term, definitions, definitionId = null) {
            console.log('shareTerm called with:', { term, definitions, definitionId });
            
            // Build URL for the current page
            let termUrl = window.location.href;
            if (definitionId) {
              termUrl += `#${definitionId}`;
            }
            
            // Use specific definition if provided, otherwise primary or first definition
            let targetDef;
            if (definitionId) {
              targetDef = definitions.find(d => d.id === definitionId);
            }
            if (!targetDef) {
              targetDef = definitions.find(d => d.isPrimary) || definitions[0];
            }
            
            const shareText = `Check out "${term}" from Floundermode Dictionary: ${termUrl}`;
            
            console.log('Generated share text:', shareText);

            // Try native share first, then clipboard
            if (navigator.share) {
              navigator.share({
                title: `${term} - Floundermode Dictionary`,
                text: shareText,
                url: termUrl
              }).catch(err => {
                console.log('Native share failed:', err);
                fallbackShare(shareText);
              });
            } else {
              fallbackShare(shareText);
            }
          };
          
          // Fallback share function
          window.fallbackShare = function(text) {
            console.log('fallbackShare called with:', text);
            
            // Try the modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
              console.log('Using modern clipboard API');
              navigator.clipboard.writeText(text).then(() => {
                console.log('Clipboard write successful');
                showToast('Copied to clipboard!');
              }).catch(err => {
                console.log('Clipboard API failed:', err);
                // Try fallback method
                tryFallbackCopy(text);
              });
            } else {
              console.log('Clipboard API not available, using fallback');
              tryFallbackCopy(text);
            }
          };
          
          // Fallback copy function
          function tryFallbackCopy(text) {
            try {
              const textArea = document.createElement('textarea');
              textArea.value = text;
              textArea.style.position = 'fixed';
              textArea.style.left = '-999999px';
              textArea.style.top = '-999999px';
              document.body.appendChild(textArea);
              textArea.focus();
              textArea.select();
              const successful = document.execCommand('copy');
              document.body.removeChild(textArea);
              
              if (successful) {
                showToast('Copied to clipboard!');
              } else {
                alert('Share text copied to clipboard!');
              }
            } catch (err) {
              console.log('Fallback copy failed:', err);
              alert('Share text copied to clipboard!');
            }
          }
          
          // Simple toast notification
          function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              background: #22c55e;
              color: white;
              padding: 12px 20px;
              border-radius: 8px;
              z-index: 10000;
              font-family: inherit;
              font-size: 14px;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            document.body.appendChild(toast);
            setTimeout(() => {
              document.body.removeChild(toast);
            }, 2000);
          }
          
          // ===== SUPABASE VOTING SYSTEM FOR HTML PAGES =====
          // Note: userVotes and allVotes are declared in main.js
          const USE_SUPABASE = true;
          
          // Initialize Supabase voting
          async function initSupabaseVoting() {
            if (USE_SUPABASE && window.supabaseVoting) {
              try {
                console.log('Initializing Supabase voting...');
                allVotes = await window.supabaseVoting.loadVoteData();
                console.log('Loaded vote data:', allVotes);
                
                // Update all vote counts on the page
                updateAllVoteCounts();
                
                // Subscribe to real-time changes
                window.supabaseVoting.subscribeToChanges((updatedVotes) => {
                  allVotes = updatedVotes;
                  updateAllVoteCounts();
                });
              } catch (error) {
                console.error('Failed to initialize Supabase voting:', error);
                // Fallback: try to load from localStorage or use default values
                console.log('Using fallback vote data');
                allVotes = {};
                updateAllVoteCounts();
              }
            } else {
              console.log('Supabase voting not available, using fallback');
              allVotes = {};
              updateAllVoteCounts();
            }
          }
          
          // Update all vote counts on the page
          function updateAllVoteCounts() {
            console.log('Updating all vote counts with data:', allVotes);
            document.querySelectorAll('.vote-count').forEach(voteCount => {
              const definitionId = voteCount.closest('.definition-item').id;
              const votes = allVotes[definitionId] || { netScore: 0 };
              console.log(`Updating ${definitionId}: ${votes.netScore}`);
              voteCount.textContent = votes.netScore;
            });
          }
          
          // Update vote count optimistically
          function updateVoteCountOptimistically(definitionId, voteChange) {
            const voteCount = document.querySelector(`#${definitionId} .vote-count`);
            if (voteCount) {
              const currentCount = parseInt(voteCount.textContent) || 0;
              voteCount.textContent = currentCount + voteChange;
              
              // Add animation class
              voteCount.classList.add('vote-updated');
              setTimeout(() => {
                voteCount.classList.remove('vote-updated');
              }, 300);
            }
          }
          
          // Submit a vote for a definition (override the one in main.js for individual pages)
          window.submitVote = async function(definitionId, voteType) {
            console.log('Voting:', definitionId, voteType);
            
            const existingVote = userVotes.get(definitionId);
            
            let voteChange = 0;
            if (existingVote === voteType) {
              userVotes.delete(definitionId);
              voteChange = voteType === 'up' ? -1 : 1;
            } else {
              userVotes.set(definitionId, voteType);
              if (existingVote) {
                voteChange = voteType === 'up' ? 2 : -2;
              } else {
                voteChange = voteType === 'up' ? 1 : -1;
              }
            }
            
            updateVoteCountOptimistically(definitionId, voteChange);
            updateVoteButtons(definitionId);
            
            // Use the saveUserVotes function from main.js
            if (window.saveUserVotes) {
              window.saveUserVotes();
            }
            
            if (USE_SUPABASE && window.supabaseVoting) {
              const result = await window.supabaseVoting.submitVote(definitionId, voteType);
              if (result) {
                allVotes = result;
                updateVoteButtons(definitionId);
              } else {
                // Revert optimistic update on failure
                updateVoteCountOptimistically(definitionId, -voteChange);
                if (existingVote === voteType) {
                  userVotes.set(definitionId, voteType);
                } else {
                  userVotes.delete(definitionId);
                }
                if (window.saveUserVotes) {
                  window.saveUserVotes();
                }
                updateVoteButtons(definitionId);
              }
            } else {
              // Fallback to local counting
              if (!allVotes[definitionId]) {
                allVotes[definitionId] = { upvotes: 0, downvotes: 0, netScore: 0 };
              }
              allVotes[definitionId].netScore += voteChange;
              if (voteType === 'up') {
                allVotes[definitionId].upvotes += (voteChange > 0 ? 1 : -1);
              } else {
                allVotes[definitionId].downvotes += (voteChange < 0 ? 1 : -1);
              }
            }
          };
          
          // Update the vote button UI
          function updateVoteButtons(definitionId) {
            const upButton = document.querySelector(`button[data-def-id="${definitionId}"].vote-up`);
            const downButton = document.querySelector(`button[data-def-id="${definitionId}"].vote-down`);
            const voteCount = document.querySelector(`button[data-def-id="${definitionId}"].vote-up`).parentElement.querySelector('.vote-count');
            
            if (upButton && downButton && voteCount) {
              const userVote = userVotes.get(definitionId);
              
              // Reset all button states
              upButton.classList.remove('voted');
              downButton.classList.remove('voted');
              
              // Apply voted state
              if (userVote === 'up') {
                upButton.classList.add('voted');
              } else if (userVote === 'down') {
                downButton.classList.add('voted');
              }
              
              // Update vote count (simple local count for demo)
              const upVotes = Array.from(userVotes.values()).filter(v => v === 'up').length;
              const downVotes = Array.from(userVotes.values()).filter(v => v === 'down').length;
              const netScore = upVotes - downVotes;
              voteCount.textContent = netScore;
            }
          }
          
          // Share definition function
          window.shareDefinition = function(definitionId) {
            const definitions = [
          {
                    "id": "def-1",
                    "definition": "This term was created to test if the GitHub Action successfully syncs new terms with Supabase database. If you can see this definition in your Supabase dashboard, the sync is working!",
                    "usage": "This is a test term to verify Supabase synchronization.",
                    "author": "GitHub Action",
                    "isPrimary": true,
                    "upvotes": 0,
                    "downvotes": 0,
                    "netScore": 0
          }
];
            const definition = definitions.find(d => d.id === definitionId);
            if (!definition) return;

            const shareText = `Supabase Sync Test: ${definition.definition}\n\n"${definition.usage}"\n\n‚Äî ${definition.author || 'Anonymous'}\n\nFrom Floundermode Dictionary`;
            
            if (navigator.share) {
              navigator.share({
                title: `Supabase Sync Test - Floundermode Dictionary`,
                text: shareText,
                url: window.location.href
              }).catch(err => console.log('Error sharing:', err));
            } else {
              // Fallback: copy to clipboard
              navigator.clipboard.writeText(shareText).then(() => {
                // Show a brief success message
                const shareBtn = document.querySelector(`[data-def-id="${definitionId}"]`);
                const originalText = shareBtn.innerHTML;
                shareBtn.innerHTML = '‚úì';
                shareBtn.style.background = '#22c55e';
                shareBtn.style.color = 'white';
                
                setTimeout(() => {
                  shareBtn.innerHTML = originalText;
                  shareBtn.style.background = '';
                  shareBtn.style.color = '';
                }, 1000);
              }).catch(err => {
                console.log('Error copying to clipboard:', err);
                alert('Share text copied to clipboard!');
              });
            }
          };

          // Initialize voting on page load
          document.addEventListener('DOMContentLoaded', async function() {
            // Load user votes using the function from main.js
            if (window.loadUserVotes) {
              window.loadUserVotes();
            }
            
            // Wait a bit to ensure all scripts are loaded
            setTimeout(async () => {
              // Initialize Supabase voting
              await initSupabaseVoting();
              
              // Update all vote buttons with current state
              document.querySelectorAll('[data-def-id]').forEach(button => {
                const defId = button.getAttribute('data-def-id');
                updateVoteButtons(defId);
              });
            }, 100);
          });
        </script>
      </div>
    </main>

    <!-- Supabase -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <!-- JavaScript Files -->
    <script src="../scripts/simple-profanity-filter.js"></script>
    <script src="../scripts/supabase-voting.js"></script>
    <script src="../scripts/main.js"></script>
    
    <script>
      // Handle deep linking to specific definitions
      function handleDefinitionDeepLink() {
        const hash = window.location.hash;
        if (hash) {
          const definitionId = hash.substring(1); // Remove the #
          const targetElement = document.getElementById(definitionId);
          if (targetElement) {
            // Scroll to the definition
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Add a subtle highlight effect
            targetElement.style.transition = 'box-shadow 0.3s ease';
            targetElement.style.boxShadow = '0 0 20px rgba(0, 123, 255, 0.5)';
            
            // Remove highlight after 3 seconds
            setTimeout(() => {
              targetElement.style.boxShadow = '';
            }, 3000);
          }
        }
      }
      
      // Run on page load
      document.addEventListener('DOMContentLoaded', handleDefinitionDeepLink);
      
      // Also run if hash changes (for single-page navigation)
      window.addEventListener('hashchange', handleDefinitionDeepLink);
    </script>
  </body>
</html>
